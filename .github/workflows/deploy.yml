name: Deploy Bot to VPS

# Minimal deploy workflow (password-based SSH). Expects these repo secrets:
# - PROD_DEPLOY_HOST
# - PROD_DEPLOY_USER
# - PROD_DEPLOY_PATH
# - PROD_SSH_PASSWORD
# Optional secrets used to populate .env:
# - PROD_DOTENV (full .env contents, optional)
# - BOT_TOKEN, DATABASE_URL, SECRET_KEY, ... (individual keys, optional)

on:
  workflow_dispatch:
    inputs:
      deployment_branch:
        description: 'Branch to deploy'
        required: true
        default: 'main'
        type: string
      deployment_type:
        description: 'Deployment type'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - backend-only

permissions:
  contents: read
  actions: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      # ensure these are available to steps that need them; set in repo secrets
      PROD_DEPLOY_PATH: ${{ secrets.PROD_DEPLOY_PATH }}
      PROD_DEPLOY_HOST: ${{ secrets.PROD_DEPLOY_HOST }}
      PROD_DEPLOY_USER: ${{ secrets.PROD_DEPLOY_USER }}
      PROD_SSH_PASSWORD: ${{ secrets.PROD_SSH_PASSWORD }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.deployment_branch }}

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass rsync util-linux

      - name: Package backend and build .env
        env:
          # optional: full dotenv content; if set it will be used instead of individual keys
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          DISCORD_TOKEN: ${{ secrets.DISCORD_TOKEN }}
          DISCORD_CLIENT_ID: ${{ secrets.DISCORD_CLIENT_ID }}
          DISCORD_CLIENT_SECRET: ${{ secrets.DISCORD_CLIENT_SECRET }}
          ADMIN_IDS: ${{ secrets.ADMIN_IDS }}
          DEVELOPER_USER_ID: ${{ secrets.DEVELOPER_USER_ID }}
          DEVELOPER_GUILD_ID: ${{ secrets.DEVELOPER_GUILD_ID }}
          LOG_LEVEL: ${{ secrets.LOG_LEVEL }}
          LEAGUEPEDIA_USER: ${{ secrets.LEAGUEPEDIA_USER }}
          LEAGUEPEDIA_PASS: ${{ secrets.LEAGUEPEDIA_PASS }}
          PANDASCORE_API_KEY: ${{ secrets.PANDASCORE_API_KEY }}
        run: |
          set -euo pipefail
          mkdir -p deployment-package

          # Copy source (exclude venv and local env files)
          rsync -av --exclude='*.pyc' --exclude='__pycache__' --exclude='.env' --exclude='venv/' \
            src/ deployment-package/src/
          cp requirements.txt deployment-package/ || true

          # Ship alembic configuration + migrations so deploys can run schema updates
          if [ -f alembic.ini ]; then
            cp alembic.ini deployment-package/
          fi

          if [ -d alembic ]; then
            rsync -av --delete alembic/ deployment-package/alembic/
          fi

          # Build deployment-package/.env either from a single PROD_DOTENV secret or by composing from individual secrets
          if [ -n "${PROD_DOTENV:-}" ]; then
            printf '%s\n' "${PROD_DOTENV}" > deployment-package/.env
          else
            # Use DATABASE_URL from secrets, or default to a persistent path if not set.
            # The env var is populated from secrets in the `env:` block above.
            cat > deployment-package/.env <<EOF
          DATABASE_URL=${DATABASE_URL:-"sqlite:///${PROD_DEPLOY_PATH}/data/prod.db"}
          DATA_PATH=${PROD_DEPLOY_PATH}/data
          DISCORD_TOKEN=${DISCORD_TOKEN:-}
          DISCORD_CLIENT_ID=${DISCORD_CLIENT_ID:-}
          DISCORD_CLIENT_SECRET=${DISCORD_CLIENT_SECRET:-}
          ADMIN_IDS=${ADMIN_IDS:-}
          DEVELOPER_USER_ID=${DEVELOPER_USER_ID:-}
          DEVELOPER_GUILD_ID=${DEVELOPER_GUILD_ID:-}
          LOG_LEVEL=${LOG_LEVEL:-INFO}
          LEAGUEPEDIA_USER=${LEAGUEPEDIA_USER:-}
          LEAGUEPEDIA_PASS=${LEAGUEPEDIA_PASS:-}
          PANDASCORE_API_KEY=${PANDASCORE_API_KEY:-}
          # Add other keys as needed; set them as repository secrets
          EOF

          fi
          chmod 600 deployment-package/.env
          echo "Packaged backend with .env (content masked by GitHub Secrets)."

      - name: Deploy to server
        run: |
          set -euo pipefail

          # Compute release path once on the runner
          RELEASE_ROOT="${PROD_DEPLOY_PATH}/releases"
          TIMESTAMP="$(date +%Y%m%d-%H%M%S)"
          REMOTE_DIR="${RELEASE_ROOT}/${TIMESTAMP}"

          echo "Creating remote release dir: ${REMOTE_DIR}"
          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} "mkdir -p '${REMOTE_DIR}'"

          echo "Uploading files to ${REMOTE_DIR}"
          rsync -avz --delete -e "sshpass -p '${PROD_SSH_PASSWORD}' ssh -o StrictHostKeyChecking=no" \
            deployment-package/ ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST}:"${REMOTE_DIR}/"

          echo "Finalizing deploy on remote host (atomic privileged block)"
          KEEP=5
          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} \
            "sudo PROD_DEPLOY_PATH='${PROD_DEPLOY_PATH}' PROD_DEPLOY_USER='${PROD_DEPLOY_USER}' REMOTE_DIR='${REMOTE_DIR}' bash -s" <<'EOF'
          set -euo pipefail
          set -x

          RELEASE_ROOT="${PROD_DEPLOY_PATH}/releases"
          KEEP=5

          mkdir -p "${RELEASE_ROOT}"

          if ! command -v python3 >/dev/null 2>&1; then
            echo "python3 not found on remote host" >&2; exit 1
          fi

          # Use the REMOTE_DIR passed from the runner (do NOT recompute TIMESTAMP/REMOTE_DIR here)
          echo "Using REMOTE_DIR: ${REMOTE_DIR}"

          # Create persistent data directory if it doesn't exist
          DATA_DIR="${PROD_DEPLOY_PATH}/data"
          if [ ! -d "${DATA_DIR}" ]; then
            echo "Creating persistent data directory: ${DATA_DIR}"
            mkdir -p "${DATA_DIR}"
            chown "${PROD_DEPLOY_USER}":"${PROD_DEPLOY_USER}" "${DATA_DIR}"
          fi

          # Create venv and install requirements inside the uploaded release
          python3 -m venv "${REMOTE_DIR}/venv"
          "${REMOTE_DIR}/venv/bin/pip" install --upgrade pip setuptools wheel || true
          if [ -f "${REMOTE_DIR}/requirements.txt" ]; then
            "${REMOTE_DIR}/venv/bin/pip" install -r "${REMOTE_DIR}/requirements.txt" || true
          fi

          # Run database migrations
          if [ -f "${REMOTE_DIR}/alembic.ini" ]; then
            echo "Running database migrations"
            # Load environment variables from .env file for the migration command
            if [ -f "${REMOTE_DIR}/.env" ]; then
              set -o allexport
              source "${REMOTE_DIR}/.env"
              set +o allexport
            fi
            # Run migrations from within the release directory
            (cd "${REMOTE_DIR}" && venv/bin/alembic upgrade head)
          fi

          # Secure the uploaded .env
          if [ -f "${REMOTE_DIR}/.env" ]; then
            chmod 600 "${REMOTE_DIR}/.env" || true
            chown ${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER} "${REMOTE_DIR}/.env" || true
          fi

          # If current exists and is not a symlink, move it to a backup to avoid ln putting the link inside it
          if [ -e "${PROD_DEPLOY_PATH}/current" ] && [ ! -L "${PROD_DEPLOY_PATH}/current" ]; then
            mv "${PROD_DEPLOY_PATH}/current" "${PROD_DEPLOY_PATH}/releases/previous-current-$(date +%Y%m%d-%H%M%S)" || true
          fi

          # Atomically update current to point to the new release
          ln -sfn "${REMOTE_DIR}" "${PROD_DEPLOY_PATH}/current"
          # Immediately show what current points to
          echo "SYMLINK_AFTER_UPDATE: $(readlink -f "${PROD_DEPLOY_PATH}/current")"

          # Fix ownership (best-effort)
          chown -R ${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER} "${REMOTE_DIR}" || true
          chown -h ${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER} "${PROD_DEPLOY_PATH}/current" || true

          # Cleanup older releases
          cd "${RELEASE_ROOT}" || exit 0
          ls -1dt * 2>/dev/null | tail -n +$((KEEP+1)) | xargs -r rm -rf || true

          # Reload and restart service and print status (so Actions logs show if restart succeeded)
          systemctl daemon-reload || true
          echo "Restarting esports-bot service to apply new release"
          systemctl restart esports-bot || true
          echo "SYSTEMD_STATUS:"
          systemctl status esports-bot --no-pager || true

          echo "Deployed to ${REMOTE_DIR}"
          EOF

          echo "Deployment finished. Current points to:"
          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} "readlink -f '${PROD_DEPLOY_PATH}/current' || true"
