name: Deploy Bot to VPS

# Minimal deploy workflow (password-based SSH). Expects these repo secrets:
# - PROD_DEPLOY_HOST
# - PROD_DEPLOY_USER
# - PROD_DEPLOY_PATH
# - PROD_SSH_PASSWORD

on:
  workflow_dispatch:
    inputs:
      deployment_branch:
        description: 'Branch to deploy'
        required: true
        default: 'main'
        type: string
      deployment_type:
        description: 'Deployment type'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - backend-only

permissions:
  contents: read
  actions: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.deployment_branch }}

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass rsync

      - name: Package backend
        run: |
          mkdir -p deployment-package
          rsync -av --exclude='*.pyc' --exclude='__pycache__' --exclude='.env' --exclude='venv/' \
            src/ deployment-package/src/
          cp requirements.txt deployment-package/

      - name: Deploy to server
        env:
          PROD_DEPLOY_PATH: ${{ secrets.PROD_DEPLOY_PATH }}
          PROD_DEPLOY_HOST: ${{ secrets.PROD_DEPLOY_HOST }}
          PROD_DEPLOY_USER: ${{ secrets.PROD_DEPLOY_USER }}
          PROD_SSH_PASSWORD: ${{ secrets.PROD_SSH_PASSWORD }}
        run: |
          set -euo pipefail

          # Release layout
          RELEASE_ROOT="${PROD_DEPLOY_PATH}/releases"
          TIMESTAMP="$(date +%Y%m%d-%H%M%S)"
          REMOTE_DIR="${RELEASE_ROOT}/${TIMESTAMP}"

          echo "Creating remote release dir: ${REMOTE_DIR}"
          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} "mkdir -p '${REMOTE_DIR}'"

          echo "Uploading files to ${REMOTE_DIR}"
          rsync -avz --delete -e "sshpass -p '${PROD_SSH_PASSWORD}' ssh -o StrictHostKeyChecking=no" \
            deployment-package/ ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST}:"${REMOTE_DIR}/"

          echo "Finalizing deploy on remote host"
          # Make the new release the 'current' symlink atomically, create a venv, install requirements,
          # set ownership, restart service, and cleanup older releases.
          KEEP=5
          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} \
            "sudo bash -lc 'set -e;
              mkdir -p \"${RELEASE_ROOT}\";
              # Ensure python3 is available
              if ! command -v python3 >/dev/null 2>&1; then
                echo \"python3 not found on remote host\" >&2; exit 1;
              fi;

              # Create venv inside the release and install requirements (if present)
              python3 -m venv \"'\"'${REMOTE_DIR}'\"'/venv\";
              \"'\"'${REMOTE_DIR}'\"'/venv/bin/pip\" install --upgrade pip setuptools wheel || true;
              if [ -f \"'\"'${REMOTE_DIR}'\"'/requirements.txt\" ]; then
                \"'\"'${REMOTE_DIR}'\"'/venv/bin/pip\" install -r \"'\"'${REMOTE_DIR}'\"'/requirements.txt\" || true;
              fi;

              # If current exists and is not a symlink, move it to a backup to avoid ln putting the link inside it
              if [ -e \"'\"'${PROD_DEPLOY_PATH}'\"'/current\" ] && [ ! -L \"'\"'${PROD_DEPLOY_PATH}'\"'/current\" ]; then
                mv \"'\"'${PROD_DEPLOY_PATH}'\"'/current\" \"'\"'${PROD_DEPLOY_PATH}'\"'/releases/previous-current-$(date +%Y%m%d-%H%M%S)\" || true;
              fi;

              # Atomically update current to point to the new release
              ln -sfn \"'\"'${REMOTE_DIR}'\"' \"'\"'${PROD_DEPLOY_PATH}'\"'/current\";
              # Fix ownership for the release dir and the symlink (best-effort)
              chown -R ${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER} \"'\"'${REMOTE_DIR}'\"'\" || true;
              chown -h ${PROD_DEPLOY_USER}:${PROD_DEPLOY_USER} \"'\"'${PROD_DEPLOY_PATH}'\"'/current\" || true;

              # Cleanup older releases
              cd \"'\"'${RELEASE_ROOT}'\"' || exit 0;
              ls -1dt * 2>/dev/null | tail -n +$((KEEP+1)) | xargs -r rm -rf || true;

              # Restart service if it exists (adjust service name if needed)
              if systemctl list-units --full -all | grep -q '^esports-bot.service'; then
                systemctl daemon-reload || true;
                systemctl restart esports-bot || true;
              fi;

              echo \"Deployed to ${REMOTE_DIR}\"'"

          echo "Deployment finished. Current points to:"
          sshpass -p "${PROD_SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no \
            ${PROD_DEPLOY_USER}@${PROD_DEPLOY_HOST} "readlink -f '${PROD_DEPLOY_PATH}/current' || true"